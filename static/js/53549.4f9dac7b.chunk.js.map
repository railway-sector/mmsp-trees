{"version":3,"file":"static/js/53549.4f9dac7b.chunk.js","mappings":"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","sources":["../node_modules/src/.internal/charts/xy/axes/CategoryAxis.ts","../node_modules/src/.internal/charts/xy/series/BaseColumnSeries.ts","../node_modules/src/.internal/charts/xy/series/ColumnSeries.ts"],"sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\nimport type { IXYSeriesDataItem, XYSeries } from \"../series/XYSeries\";\n\nimport { Axis, IAxisSettings, IAxisPrivate, IAxisDataItem, IAxisEvents } from \"./Axis\";\nimport { populateString } from \"../../../core/util/PopulateString\";\nimport { ValueAxis } from \"./ValueAxis\";\n\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\n\nexport interface ICategoryAxisSettings<R extends AxisRenderer> extends IAxisSettings<R> {\n\n\t/**\n\t * A function that can be used to specify how to configure axis fills.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_fills} for more info\n\t */\n\tfillRule?: (dataItem: DataItem<ICategoryAxisDataItem>, index?: number) => void;\n\n\t/**\n\t * A field in data which holds categories.\n\t */\n\tcategoryField: string;\n\n\t/**\n\t * A key to look up in data for an id of the data item.\n\t */\n\tidField?: string;\n\n\t/**\n\t * A key to look up in data for a relative size value of the data item. \n\t */\n\tcellSizeField?: string;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n}\n\nexport interface ICategoryAxisDataItem extends IAxisDataItem {\n\n\t/**\n\t * Named category.\n\t */\n\tcategory?: string;\n\n\t/**\n\t * Named end category (for axis items that span multiple categories, like\n\t * axis ranges).\n\t */\n\tendCategory?: string;\n\n\t/**\n\t * Index of the data item.\n\t */\n\tindex?: number;\n\n\t/**\n\t * Relative location of the category within cell: 0 - start, 1 - end.\n\t */\n\tcategoryLocation?: number;\n\n\t/**\n\t * Relative location of the end category within cell: 0 - start, 1 - end.\n\t */\n\tendCategoryLocation?: number;\n\n\t/**\n\t * A distance to shift data item relative to its original position.\n\t *\n\t * The value is 0 to 1, where 1 is full witdth of the axis.\n\t *\n\t * Can be used to sort data items without modifying order of the actual data.\n\t */\n\tdeltaPosition?: number;\n\n\t/**\n\t * A size of the category cell.\n\t *\n\t * NOTE: This value is used only if `cellSizeField` is set on the series.\n\t */\n\tcellSize?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tfinalCellSize?: number;\n\n\t/**\n\t * A unique id of the data item.\n\t */\n\tid?: string;\n}\n\nexport interface ICategoryAxisPrivate extends IAxisPrivate {\n\n\t/**\n\t * Start index of the current zoom scope.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * End index of the current zoom scope.\n\t */\n\tendIndex?: number;\n}\n\nexport interface ICategoryAxisEvents extends IAxisEvents {\n\n}\n\n/**\n * Creates a category axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info\n * @important\n */\nexport class CategoryAxis<R extends AxisRenderer> extends Axis<R> {\n\tpublic static className: string = \"CategoryAxis\";\n\tpublic static classNames: Array<string> = Axis.classNames.concat([CategoryAxis.className]);\n\n\tdeclare public _settings: ICategoryAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryAxisDataItem;\n\tdeclare public _events: ICategoryAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\", \"id\", \"cellSize\");\n\t\tthis.setPrivateRaw(\"name\", \"category\");\n\t\tthis.addTag(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\tpublic _afterDataChange(): void {\n\t\tsuper._afterDataChange();\n\t\tconst len = this.dataItems.length;\n\t\tif (len > 0) {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", len);\n\t\t}\n\n\t\t// fix final indexes\t\t\n\t\tthis.setPrivateRaw(\"startIndex\", Math.min(this.getPrivate(\"startIndex\", 0), len));\n\t\tthis.setPrivateRaw(\"endIndex\", Math.min(this.getPrivate(\"endIndex\", len), 1));\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tconst len = this.dataItems.length;\n\t\tlet i = 0;\n\t\tif (this._valuesDirty) {\n\t\t\tthis._itemMap = {};\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tdataItem.setRaw(\"index\", i);\n\t\t\t\tthis._itemMap[dataItem.get(\"category\") as string] = dataItem;\n\t\t\t\ti++;\n\t\t\t})\n\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", len);\n\t\t}\n\n\t\tlet start = this.get(\"start\", 0);\n\t\tlet end = this.get(\"end\", 1);\n\t\t\n\t\tlet indices = this._getIndices(start, end);\n\n\t\tthis.setPrivateRaw(\"startIndex\", indices.startIndex);\n\t\tthis.setPrivateRaw(\"endIndex\", indices.endIndex);\n\n\t\tif (this._sizeDirty || this._valuesDirty || (this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"endIndex\") || this.isPrivateDirty(\"startIndex\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\"))) {\n\t\t\tif (this.dataItems.length > 0) {\n\t\t\t\tthis._handleRangeChange();\n\t\t\t\tthis._prepareAxisItems();\n\t\t\t\tthis._updateAxisRanges();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic adjustZoom(): void {\n\t\tconst len = this.dataItems.length;\n\t\tif (len > 1) {\n\t\t\tlet maxZoomCount = this.get(\"maxZoomCount\", this.dataItems.length);\n\t\t\tlet minZoomCount = this.get(\"minZoomCount\", 1);\n\n\t\t\tlet count = 0;\n\t\t\tlet startIndex = this.getPrivate(\"startIndex\", 0);\n\t\t\tlet endIndex = this.getPrivate(\"endIndex\", 0);\n\n\t\t\tconst sAnimation = this._sAnimation;\n\t\t\tconst eAnimation = this._eAnimation;\n\n\t\t\tlet start = this.get(\"start\", 0);\n\t\t\tlet getIndices = false;\n\t\t\tif (sAnimation && !sAnimation.stopped) {\n\t\t\t\tstart = Number(sAnimation.to);\n\t\t\t\tgetIndices = true;\n\t\t\t}\n\t\t\tlet end = this.get(\"end\", 1);\n\t\t\tif (eAnimation && !eAnimation.stopped) {\n\t\t\t\tend = Number(eAnimation.to);\n\t\t\t\tgetIndices = true;\n\t\t\t}\n\n\t\t\tif (getIndices) {\n\t\t\t\tconst indices = this._getIndices(start, end);\n\t\t\t\tstartIndex = indices.startIndex;\n\t\t\t\tendIndex = indices.endIndex;\n\t\t\t}\n\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\tcount += dataItem.get(\"finalCellSize\", 1);\n\t\t\t};\n\n\t\t\tif (count <= minZoomCount) {\n\t\t\t\t// need to zoom out\n\t\t\t\tlet c = 0;\n\n\t\t\t\tfor (let i = startIndex; i < len; i++) {\n\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\tc += dataItem.get(\"finalCellSize\", 1);\n\n\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\tif (c >= minZoomCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c < minZoomCount) {\n\t\t\t\t\t// still not enough, try to extend at the start\n\t\t\t\t\tfor (let i = startIndex - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\t\tc += dataItem.get(\"finalCellSize\", 1);\n\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t\tif (c >= minZoomCount) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.zoomToIndexes(startIndex, endIndex);\n\t\t\t}\n\t\t\telse if (count >= maxZoomCount) {\n\t\t\t\tlet c = count;\n\t\t\t\tfor (let i = endIndex - 1; i >= startIndex; i--) {\n\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\tc -= dataItem.get(\"finalCellSize\", 1);\n\t\t\t\t\tif (c <= maxZoomCount) {\n\t\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.zoomToIndexes(startIndex, endIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _handleRangeChange() {\n\t\t$array.each(this.series, (series) => {\n\t\t\tlet startCategory = this.dataItems[this.startIndex()].get(\"category\")!;\n\t\t\tlet endCategory = this.dataItems[this.endIndex() - 1].get(\"category\")!;\n\n\t\t\tlet baseAxis = series.get(\"baseAxis\");\n\t\t\tlet xAxis = series.get(\"xAxis\");\n\t\t\tlet yAxis = series.get(\"yAxis\");\n\n\t\t\tif (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n\t\t\t\tseries._markDirtyAxes();\n\t\t\t}\n\t\t\telse if (baseAxis === this) {\n\t\t\t\tlet key: string | undefined;\n\t\t\t\tlet openKey: string | undefined;\n\t\t\t\tlet otherAxis = yAxis;\n\t\t\t\tif (xAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryXField\")) {\n\t\t\t\t\t\tkey = \"categoryX\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryXField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryX\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (yAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryYField\")) {\n\t\t\t\t\t\tkey = \"categoryY\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryYField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryY\";\n\t\t\t\t\t}\n\t\t\t\t\totherAxis = xAxis;\n\t\t\t\t}\n\n\t\t\t\tif (otherAxis instanceof ValueAxis) {\n\n\t\t\t\t\tif (key || openKey) {\n\t\t\t\t\t\tlet startDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t\t\tlet endDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\n\t\t\t\t\t\tfunction findDataItem(\n\t\t\t\t\t\t\tseries: XYSeries,\n\t\t\t\t\t\t\tcategoryAxis: CategoryAxis<any>,\n\t\t\t\t\t\t\tkey: string | undefined,\n\t\t\t\t\t\t\topenKey: string | undefined,\n\t\t\t\t\t\t\tcategory: string,\n\t\t\t\t\t\t\tdirection: \"previous\" | \"next\"\n\t\t\t\t\t\t): DataItem<IXYSeriesDataItem> | undefined {\n\t\t\t\t\t\t\tlet dataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t\t\t\tlet idx = categoryAxis.categoryToIndex(category!);\n\n\t\t\t\t\t\t\twhile (!dataItem && idx >= 0 && idx < categoryAxis.dataItems.length) {\n\t\t\t\t\t\t\t\tlet searchCategory = categoryAxis.dataItems[idx].get(\"category\");\n\t\t\t\t\t\t\t\tif (direction == \"previous\") {\n\t\t\t\t\t\t\t\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\t\t\t\tlet item = series.dataItems[i];\n\t\t\t\t\t\t\t\t\t\tif (key && item.get(key as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (openKey && item.get(openKey as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\t\t\t\t\t\t\tlet item = series.dataItems[i];\n\t\t\t\t\t\t\t\t\t\tif (key && item.get(key as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (openKey && item.get(openKey as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!dataItem) {\n\t\t\t\t\t\t\t\t\tidx += direction === \"previous\" ? -1 : 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstartDataItem = findDataItem(series, this, key, openKey, startCategory, \"next\");\n\t\t\t\t\t\tendDataItem = findDataItem(series, this, key, openKey, endCategory, \"previous\");\n\n\t\t\t\t\t\tlet startIndex = 0;\n\t\t\t\t\t\tlet endIndex = series.dataItems.length;\n\n\t\t\t\t\t\tif (startDataItem) {\n\t\t\t\t\t\t\tstartIndex = series.dataItems.indexOf(startDataItem);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (endDataItem) {\n\t\t\t\t\t\t\tendIndex = series.dataItems.indexOf(endDataItem) + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseries.setPrivate(\"startIndex\", startIndex);\n\t\t\t\t\t\tseries.setPrivate(\"endIndex\", endIndex);\n\n\t\t\t\t\t\tlet hasValue = false;\n\t\t\t\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\t\t\t\tconst dataItem = series.dataItems[i];\n\n\t\t\t\t\t\t\t$array.each(series.__valueXShowFields, (key) => {\n\t\t\t\t\t\t\t\tlet value = dataItem.get(<any>key);\n\t\t\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t\t\thasValue = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t$array.each(series.__valueYShowFields, (key) => {\n\t\t\t\t\t\t\t\tlet value = dataItem.get(<any>key);\n\t\t\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t\t\thasValue = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tif (hasValue) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseries.setPrivate(\"outOfSelection\", !hasValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseries._markDirtyAxes();\t// must be outside\n\t\t\t}\n\t\t})\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tconst minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n\t\tconst minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1);\n\n\t\tlet frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));\n\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis._toggleDataItem(this.dataItems[j], false);\n\t\t}\n\n\t\tlet f = this.dataItems[startIndex].get(\"index\", 0);\n\n\t\tfor (let i = startIndex; i < endIndex; i = i + frequency) {\n\t\t\tlet dataItem = this.dataItems[i];\n\n\t\t\tthis._createAssets(dataItem, []);\n\t\t\tthis._toggleDataItem(dataItem, true);\n\n\t\t\tlet count = frequency;\n\t\t\tif (minorGridEnabled) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\n\t\t\tthis._prepareDataItem(dataItem, f, count);\n\n\t\t\tf++;\n\t\t}\n\n\t\tif (renderer.get(\"minorGridEnabled\")) {\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\tif (i % frequency != 0) {\n\t\t\t\t\tthis._createAssets(dataItem, [\"minor\"], true);\n\t\t\t\t\tthis._toggleDataItem(dataItem, true);\n\t\t\t\t\tthis._prepareDataItem(dataItem, 0, 1);\n\n\t\t\t\t\tif (!minorLabelsEnabled) {\n\t\t\t\t\t\tdataItem.get(\"label\")?.setPrivate(\"visible\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\n\tpublic _prepareDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, fillIndex?: number, count?: number) {\n\t\tlet renderer = this.get(\"renderer\");\n\n\t\tlet categoryLocation = dataItem.get(\"categoryLocation\", 0);\n\t\tlet endCategoryLocation = dataItem.get(\"endCategoryLocation\", 1);\n\n\t\tlet index: number | undefined = dataItem.get(\"index\");\n\n\t\tif (!$type.isNumber(index)) {\n\t\t\tindex = this.categoryToIndex(dataItem.get(\"category\")!);\n\t\t}\n\n\t\tlet position = this.indexToPosition(index, categoryLocation);\n\n\t\tlet endCategory = dataItem.get(\"endCategory\")!;\n\t\tlet endIndex: number;\n\t\tif (endCategory) {\n\t\t\tendIndex = this.categoryToIndex(endCategory);\n\t\t\tif (!$type.isNumber(endIndex)) {\n\t\t\t\tendIndex = index;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tendIndex = index;\n\t\t}\n\n\t\tlet endPosition = this.indexToPosition(endIndex, endCategoryLocation);\n\n\t\tlet fillEndIndex: number;\n\t\tlet fillEndPosition: number;\n\n\t\tif (dataItem.get(\"isRange\")) {\n\t\t\tfillEndIndex = endIndex;\n\n\t\t\tif (!$type.isNumber(index)) {\n\t\t\t\tthis._toggleDataItem(dataItem, false);\n\t\t\t\treturn;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfillEndIndex = index + this._frequency - 1;\n\t\t}\n\n\t\tfillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);\n\n\t\trenderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n\t\trenderer.updateGrid(dataItem.get(\"grid\"), position, endPosition);\n\t\trenderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n\t\trenderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\n\t\tthis._processBullet(dataItem);\n\t\trenderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n\t\tconst fillRule = this.get(\"fillRule\");\n\t\tif (fillRule) {\n\t\t\tfillRule(dataItem, fillIndex)\n\t\t}\n\t}\n\n\tpublic startIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.min(Math.max(this.getPrivate(\"startIndex\", 0), 0), len - 1);\n\t}\n\n\tpublic endIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.max(1, Math.min(this.getPrivate(\"endIndex\", len), len));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic baseValue(): any {\n\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic basePosition() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         X coordinate\n\t */\n\tpublic getX(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns Y coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         Y coordinate\n\t */\n\tpublic getY(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * Converts category index to a relative position.\n\t *\n\t * `location` indicates relative position within category: 0 - start, 1 - end.\n\t *\n\t * If not set, will use middle (0.5) of the category.\n\t *\n\t * @param   index     Index\n\t * @param   location  Location\n\t * @return            Index\n\t */\n\tpublic indexToPosition(index: number, location?: number, final?: boolean): number {\n\t\tlet len = this.dataItems.length;\n\t\tlet position = 0;\n\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (index >= len) {\n\t\t\tindex = len - 1;\n\t\t\tlocation = 1;\n\t\t}\n\n\t\tif (!$type.isNumber(location)) {\n\t\t\tlocation = 0.5;\n\t\t}\n\n\t\tif (!$type.isNumber(index)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet startLocation = this.get(\"startLocation\", 0);\n\t\tlet endLocation = this.get(\"endLocation\", 1);\n\n\t\tif (!this.get(\"cellSizeField\")) {\n\t\t\tlen -= startLocation;\n\t\t\tlen -= (1 - endLocation);\n\n\t\t\tposition = (index + location - startLocation) / len;\n\t\t}\n\t\telse {\n\t\t\tlet name: \"finalCellSize\" | \"cellSize\" = final ? \"finalCellSize\" : \"cellSize\";\n\n\t\t\tconst dataItems = this.dataItems;\n\n\t\t\t// Calculate total modified count (sum of cell sizes)\n\t\t\tlet modCount = 0;\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tmodCount += dataItem.get(name, 1);\n\t\t\t});\n\n\t\t\tmodCount -= startLocation * dataItems[0].get(name, 1);\n\t\t\tmodCount -= (1 - endLocation) * dataItems[dataItems.length - 1].get(name, 1);\n\n\t\t\t// Calculate the position based on cell sizes\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < index; i++) {\n\t\t\t\tacc += dataItems[i].get(name, 1);\n\t\t\t}\n\t\t\tlet cellSizeAtIndex = dataItems[index].get(name, 1);\n\n\t\t\tposition = (acc + location * cellSizeAtIndex - startLocation * dataItems[0].get(name, 1)) / modCount;\n\t\t}\n\n\t\tif (!final) {\n\t\t\tlet dataItem = this.dataItems[index];\n\t\t\tif (dataItem) {\n\t\t\t\tposition += dataItem.get(\"deltaPosition\", 0);\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Returns a position of a category.\n\t *\n\t * @param   category  Category to look up\n\t * @return            Position\n\t */\n\tpublic categoryToPosition(category: string): number {\n\t\tlet dataItem = this._itemMap[category];\n\t\tif (dataItem) {\n\t\t\treturn this.indexToPosition(dataItem.get(\"index\")!);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\n\t/**\n\t * Returns an index of a category.\n\t *\n\t * @param   category  Category to look up\n\t * @return            Index\n\t */\n\tpublic categoryToIndex(category: string): number {\n\t\tlet dataItem = this._itemMap[category];\n\t\tif (dataItem) {\n\t\t\treturn dataItem.get(\"index\")!;\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic dataItemToPosition(dataItem: DataItem<this[\"_dataItemSettings\"]>): number {\n\t\treturn this.indexToPosition(dataItem.get(\"index\")!);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tposition += (0.5 - location) / this.dataItems.length;\n\t\treturn this.indexToPosition(this.axisPositionToIndex(position), location);\n\t}\n\n\t/**\n\t * Returns an index of the category that corresponds to specific pixel\n\t * position within axis.\n\t *\n\t * @param position  Position (px)\n\t * @return Category index\n\t */\n\tpublic axisPositionToIndex(position: number): number {\n\t\tlet len = this.dataItems.length;\n\t\tif (len === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Calculate total modified length (sum of cell sizes)\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tlet modifiedLen = 0;\n\t\t\tlet cellSizes: number[] = [];\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tconst cellSize = dataItem.get(\"cellSize\", 1);\n\t\t\t\tcellSizes.push(cellSize);\n\t\t\t\tmodifiedLen += cellSize;\n\t\t\t});\n\t\t\t// Adjust for startLocation and endLocation\n\t\t\tlet startLocation = this.get(\"startLocation\", 0);\n\t\t\tlet endLocation = this.get(\"endLocation\", 1);\n\t\t\tmodifiedLen -= startLocation;\n\t\t\tmodifiedLen -= (1 - endLocation);\n\n\t\t\t// Find which cell the position falls into\n\t\t\tlet rel = position * modifiedLen + startLocation;\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst cellSize = cellSizes[i];\n\t\t\t\tif (rel < acc + cellSize) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\tacc += cellSize;\n\t\t\t}\n\t\t\treturn len - 1;\n\t\t}\n\t\telse {\n\t\t\treturn $math.fitToRange(Math.floor(position * len), 0, len - 1);\n\t\t}\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number, _adjustPosition?: boolean): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tconst dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\t\tif (dataItem) {\n\t\t\tconst label = dataItem.get(\"label\")\n\t\t\tif (label) {\n\t\t\t\treturn populateString(label, this.get(\"tooltipText\", \"\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);\n\t\ttooltip.label.text.markDirtyText();\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tif (this.dataItems.length > 0) {\n\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\t\tlet index = this.axisPositionToIndex(position);\n\t\t\t// try simple first\n\t\t\tlet seriesDataItem = series.dataItems[index];\n\t\t\tlet axisDataItem = this.dataItems[index];\n\t\t\tlet category = axisDataItem.get(\"category\");\n\n\t\t\tif (seriesDataItem && axisDataItem) {\n\t\t\t\tif (seriesDataItem.get(fieldName) === category) {\n\t\t\t\t\treturn seriesDataItem;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if not found, try looking\n\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\tif (dataItem.get(fieldName) === category) {\n\t\t\t\t\treturn dataItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _getIndices(start: number, end: number): { startIndex: number, endIndex: number } {\n\t\tlet len = this.dataItems.length;\n\t\tlet startIndex = 0;\n\t\tlet endIndex = len;\n\t\tlet name: \"cellSize\" | \"finalCellSize\" = \"cellSize\";\n\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tlet count = 0;\n\t\t\tconst dataItems = this.dataItems;\n\t\t\tif(dataItems.length == 0){\n\t\t\t\treturn { startIndex: 0, endIndex: 0 };\n\t\t\t}\n\n\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\tcount += dataItem.get(name, 1);\n\t\t\t});\n\n\t\t\tcount -= this.get(\"startLocation\", 0) * dataItems[0].get(name, 1);\n\t\t\tcount -= (1 - this.get(\"endLocation\", 1)) * dataItems[dataItems.length - 1].get(name, 1);\n\n\t\t\tlet c = 0;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tc += this.dataItems[i].get(name, 1);\n\t\t\t\tif (Math.round(c) > Math.round(start * count)) {\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = startIndex + 1; i < len; i++) {\n\t\t\t\tc += this.dataItems[i].get(name, 1);\n\t\t\t\tif (Math.round(c) >= Math.round(end * count)) {\n\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartIndex = Math.max(startIndex, 0);\n\t\t\tendIndex = Math.min(endIndex, len);\n\t\t}\n\t\telse {\n\t\t\tstartIndex = Math.max(Math.round(this.get(\"start\", 0) * len), 0);\n\t\t\tendIndex = Math.min(Math.round(this.get(\"end\", 1) * len), len);\n\t\t}\n\n\t\treturn { startIndex, endIndex };\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` indexes.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start index\n\t * @param  end       End index\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToIndexes(start: number, end: number, duration?: number) {\n\t\tlet len = this.dataItems.length;\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tstart = Math.min(Math.max(start, 0), len);\n\t\t\tend = Math.max(Math.min(end, len), 1);\n\t\t\tthis.setPrivateRaw(\"startIndex\", start);\n\t\t\tthis.setPrivateRaw(\"endIndex\", end);\n\t\t\tthis.zoom(this.indexToPosition(start, 0, true), this.indexToPosition(end, 0, true), duration);\n\t\t}\n\t\telse {\n\t\t\tthis.zoom(start / len, end / len, duration);\n\t\t}\n\t}\n\n\tpublic zoomToCategories(startCategory: string, endCategory: string, duration?: number) {\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);\n\t}\n\n\t/**\n\t * Returns position span between start and end of a single cell in axis.\n\t *\n\t * @since 5.2.30\n\t * @return Position\n\t */\n\tpublic getCellWidthPosition(): number {\n\t\treturn this._frequency / this.dataItems.length / (this.get(\"end\", 1) - this.get(\"start\", 0));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic nextPosition(count?: number) {\n\t\tif (count == null) {\n\t\t\tcount = 1;\n\t\t}\n\n\t\tif (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n\t\t\tcount *= -1;\n\t\t}\n\n\t\tconst position = this.getPrivate(\"tooltipPosition\", 0);\n\n\t\tconst index = $math.fitToRange(this.axisPositionToIndex(position) + count, 0, this.dataItems.length - 1);\n\t\treturn this.toGlobalPosition(this.indexToPosition(index));\n\t}\n}\n","import type { DataItem } from \"../../../core/render/Component\";\nimport type { Graphics } from \"../../../core/render/Graphics\";\nimport type { Template } from \"../../../core/util/Template\";\nimport type { ListTemplate } from \"../../../core/util/List\";\nimport type { CategoryAxis } from \"../axes/CategoryAxis\";\nimport type { DateAxis } from \"../axes/DateAxis\";\nimport type { ValueAxis } from \"../axes/ValueAxis\";\nimport type { IAxisDataItem } from \"../axes/Axis\";\nimport type { ILegendDataItem } from \"../../../core/render/Legend\";\nimport type { Sprite } from \"../../../core/render/Sprite\";\n\nimport { XYSeries, IXYSeriesPrivate, IXYSeriesSettings, IXYSeriesDataItem, IXYSeriesAxisRange } from \"./XYSeries\";\nimport { Percent } from \"../../../core/util/Percent\";\nimport { visualSettings } from \"../../../core/render/Graphics\";\n\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\n\nexport interface IBaseColumnSeriesDataItem extends IXYSeriesDataItem {\n\n\t/**\n\t * An actual [[Graphics]] element (Column/Slice/Candlestick/OHLC).\n\t */\n\tgraphics?: Graphics;\n\n\t/**\n\t * In case axis ranges are added to the series, it creates a separate\n\t * element ([[Graphics]]) for each axis range. This array holds them all.\n\t */\n\trangeGraphics?: Array<Graphics>;\n\n\t/**\n\t * If data items from this series are used to feed a [[Legend]], this\n\t * will hold a reference to the equivalent Legend data item.\n\t * \n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/#Data_item_list} for more info\n\t */\n\tlegendDataItem?: DataItem<ILegendDataItem>;\n}\n\nexport interface IBaseColumnSeriesSettings extends IXYSeriesSettings {\n\n\t/**\n\t * Indicates if series must divvy up available space with other column\n\t * series (`true`; default) or take up the whole available space (`false`).\n\t *\n\t * @default true\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/column-series/#Clustering} for more info\n\t */\n\tclustered?: boolean;\n\n\t/**\n\t * Whether positions of bullets should be calculated based on portion of\n\t * column currently visual (`true`) or the whole length/height of the\n\t * column (`false`).\n\t *\n\t * @default true\n\t */\n\tadjustBulletPosition?: boolean;\n\n\t/**\n\t * If set to `true` will use color of the last visible column for legend\n\t * marker. Otherwise, series `fill`/`stroke` will be used.\n\t *\n\t * @since 5.1.13\n\t */\n\tuseLastColorForLegendMarker?: boolean\n\n}\n\nexport interface IBaseColumnSeriesPrivate extends IXYSeriesPrivate { }\n\nexport interface IBaseColumnSeriesAxisRange extends IXYSeriesAxisRange {\n\n\t/**\n\t * A list of actual [[Graphics]] elements for an axis range.\n\t *\n\t * Can be used to ajust the look of the axis range columns.\n\t */\n\tcolumns: ListTemplate<Graphics>;\n\n}\n\n/**\n * Base class for all \"column-based\" series\n */\nexport abstract class BaseColumnSeries extends XYSeries {\n\n\tdeclare public _settings: IBaseColumnSeriesSettings;\n\tdeclare public _privateSettings: IBaseColumnSeriesPrivate;\n\tdeclare public _dataItemSettings: IBaseColumnSeriesDataItem;\n\tdeclare public _axisRangeType: IBaseColumnSeriesAxisRange;\n\n\tpublic static className: string = \"BaseColumnSeries\";\n\tpublic static classNames: Array<string> = XYSeries.classNames.concat([BaseColumnSeries.className]);\n\n\t/**\n\t * @ignore\n\t */\n\tpublic abstract makeColumn(dataItem: DataItem<this[\"_dataItemSettings\"]>, listTemplate: ListTemplate<Graphics>): Graphics\n\n\t/**\n\t * ListTemplate of columns in series.\n\t */\n\tpublic abstract columns: ListTemplate<Graphics>;\n\n\tprotected _makeGraphics(listTemplate: ListTemplate<Graphics>, dataItem: DataItem<this[\"_dataItemSettings\"]>): Graphics {\n\t\treturn this.makeColumn(dataItem, listTemplate);\n\t}\n\n\tprotected _ph: number = 0;\n\tprotected _pw: number = 0;\n\n\tprotected _columnsUpdated: boolean = false;\n\n\tpublic _makeFieldNames() {\n\t\tsuper._makeFieldNames();\n\n\t\tconst xAxis = this.get(\"xAxis\");\n\t\tconst yAxis = this.get(\"yAxis\");\n\n\t\tconst categoryAxis = \"CategoryAxis\";\n\t\tconst valueAxis = \"ValueAxis\";\n\n\t\tif (xAxis.isType<CategoryAxis<any>>(categoryAxis)) {\n\t\t\tif (!this.get(\"openCategoryXField\")) {\n\t\t\t\tthis._xOpenField = this._xField;\n\t\t\t}\n\t\t}\n\n\t\tif (xAxis.isType<DateAxis<any>>(valueAxis)) {\n\t\t\tif (!this.get(\"openValueXField\")) {\n\t\t\t\tthis._xOpenField = this._xField;\n\t\t\t}\n\t\t}\n\n\t\tif (yAxis.isType<CategoryAxis<any>>(categoryAxis)) {\n\t\t\tif (!this.get(\"openCategoryYField\")) {\n\t\t\t\tthis._yOpenField = this._yField;\n\t\t\t}\n\t\t}\n\n\t\tif (yAxis.isType<DateAxis<any>>(valueAxis)) {\n\t\t\tif (!this.get(\"openValueYField\")) {\n\t\t\t\tthis._yOpenField = this._yField;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tconst xAxis = this.get(\"xAxis\");\n\t\tconst yAxis = this.get(\"yAxis\");\n\n\t\tconst len = this.dataItems.length;\n\t\tconst startIndex = Math.max(0, this.startIndex() - 2);\n\t\tconst endIndex = Math.min(this.endIndex() + 2, len - 1);\n\n\t\tif (xAxis.inited && yAxis.inited) {\n\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\tthis._createGraphics(dataItem);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _updateChildren() {\n\t\tconst chart = this.chart;\n\t\tif (chart) {\n\t\t\tthis._ph = chart.plotContainer.height();\n\t\t\tthis._pw = chart.plotContainer.width();\n\t\t}\n\n\t\tconst xAxis = this.get(\"xAxis\");\n\t\tconst yAxis = this.get(\"yAxis\");\n\t\tconst baseAxis = this.get(\"baseAxis\")!;\n\n\t\tconst columnsTemplate = this.columns.template;\n\t\tif (this.isDirty(\"fill\")) {\n\t\t\tif (columnsTemplate.get(\"fill\") == null) {\n\t\t\t\tcolumnsTemplate.set(\"fill\", this.get(\"fill\"));\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"fillPattern\")) {\n\t\t\tif (columnsTemplate.get(\"fillPattern\") == null) {\n\t\t\t\tcolumnsTemplate.set(\"fillPattern\", this.get(\"fillPattern\"));\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"stroke\")) {\n\t\t\tif (columnsTemplate.get(\"stroke\") == null) {\n\t\t\t\tcolumnsTemplate.set(\"stroke\", this.get(\"stroke\"));\n\t\t\t}\n\t\t}\n\n\t\tlet index = 0;\n\t\tlet clusterCount = 0;\n\t\tlet i = 0;\n\n\t\t$array.each(baseAxis.series, (series) => {\n\t\t\tif (series instanceof BaseColumnSeries) {\n\t\t\t\tconst stacked = series.get(\"stacked\");\n\n\t\t\t\tif (stacked && i == 0) {\n\t\t\t\t\tclusterCount++;\n\t\t\t\t}\n\n\t\t\t\tif (!stacked && series.get(\"clustered\")) {\n\t\t\t\t\tclusterCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (series === this) {\n\t\t\t\tindex = clusterCount - 1;\n\t\t\t}\n\t\t\ti++;\n\t\t})\n\n\t\tif (!this.get(\"clustered\")) {\n\t\t\tindex = 0;\n\t\t\tclusterCount = 1;\n\t\t}\n\n\t\tif (clusterCount === 0) {\n\t\t\tclusterCount = 1;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tconst xRenderer = xAxis.get(\"renderer\");\n\t\tconst yRenderer = yAxis.get(\"renderer\");\n\n\t\tconst cellStartLocation = \"cellStartLocation\";\n\t\tconst cellEndLocation = \"cellEndLocation\";\n\n\t\tconst cellLocationX0 = xRenderer.get(cellStartLocation, 0);\n\t\tconst cellLocationX1 = xRenderer.get(cellEndLocation, 1);\n\n\t\tconst cellLocationY0 = yRenderer.get(cellStartLocation, 0);\n\t\tconst cellLocationY1 = yRenderer.get(cellEndLocation, 1);\n\n\t\tthis._aLocationX0 = cellLocationX0 + (index / clusterCount) * (cellLocationX1 - cellLocationX0);\n\t\tthis._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);;\n\n\t\tthis._aLocationY0 = cellLocationY0 + (index / clusterCount) * (cellLocationY1 - cellLocationY0);\n\t\tthis._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);\n\n\t\tif (xAxis.inited && yAxis.inited) {\n\t\t\tif (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty(\"vcx\") || this.isDirty(\"vcy\") || this._sizeDirty) {\n\t\t\t\tconst len = this.dataItems.length;\n\n\t\t\t\tlet startIndex = Math.max(0, this.startIndex() - 2);\n\t\t\t\tlet endIndex = Math.min(this.endIndex() + 2, len - 1);\n\n\t\t\t\tfor (let i = 0; i < startIndex; i++) {\n\t\t\t\t\tthis._toggleColumn(this.dataItems[i], false);\n\t\t\t\t}\n\t\t\t\tlet previous = this.dataItems[startIndex];\n\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\t\tif (dataItem.get(\"valueX\") != null && dataItem.get(\"valueY\") != null) {\n\t\t\t\t\t\tprevious = dataItem;\n\t\t\t\t\t\tif (i > 0 && startIndex > 0) {\n\t\t\t\t\t\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tlet dataItem = this.dataItems[j];\n\t\t\t\t\t\t\t\tif (dataItem.get(\"valueX\") != null && dataItem.get(\"valueY\") != null) {\n\t\t\t\t\t\t\t\t\tprevious = dataItem;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._toggleColumn(dataItem, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._beforeColumnsDraw();\n\n\t\t\t\tlet axisCase: 0 | 1 | 2 = 0;\n\n\t\t\t\tif (yAxis.isType<CategoryAxis<any>>(\"CategoryAxis\") && xAxis.isType<CategoryAxis<any>>(\"CategoryAxis\")) {\n\t\t\t\t\taxisCase = 2;\n\t\t\t\t}\n\t\t\t\telse if (xAxis === baseAxis) {\n\t\t\t\t\taxisCase = 0;\n\t\t\t\t}\n\t\t\t\telse if (yAxis === baseAxis) {\n\t\t\t\t\taxisCase = 1;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\t\tthis._updateGraphics(dataItem, previous, axisCase);\n\t\t\t\t\tif (dataItem.get(\"valueX\") != null && dataItem.get(\"valueY\") != null) {\n\t\t\t\t\t\tprevious = dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._afterColumnsDraw();\n\n\t\t\t\tfor (let i = endIndex + 1; i < len; i++) {\n\t\t\t\t\tthis._toggleColumn(this.dataItems[i], false);\n\t\t\t\t}\n\t\t\t\tthis._columnsUpdated = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._skipped = true;\n\t\t}\n\t\tif (!this.getPrivate(\"doNotUpdateLegend\")) {\n\t\t\tthis.updateLegendMarker(this.get(\"tooltipDataItem\"));\n\t\t}\n\t\tsuper._updateChildren();\n\t}\n\n\tpublic _afterChanged(): void {\n\t\tsuper._afterChanged();\n\t\tthis._columnsUpdated = false;\n\t}\n\tprotected _beforeColumnsDraw() {\n\n\t}\n\n\tprotected _afterColumnsDraw() {\n\n\t}\n\n\n\tprotected _createGraphics(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tlet graphics = dataItem.get(\"graphics\");\n\t\tif (!graphics) {\n\n\t\t\tgraphics = this._makeGraphics(this.columns, dataItem);\n\t\t\tdataItem.set(\"graphics\", graphics);\n\t\t\tgraphics._setDataItem(dataItem);\n\n\t\t\tconst legendDataItem = dataItem.get(\"legendDataItem\");\n\t\t\tif (legendDataItem) {\n\t\t\t\tconst markerRectangle = legendDataItem.get(\"markerRectangle\");\n\t\t\t\tif (markerRectangle) {\n\t\t\t\t\tconst ds = markerRectangle.states.lookup(\"default\")!;\n\t\t\t\t\t$array.each(visualSettings, (setting: any) => {\n\t\t\t\t\t\tconst value = graphics!.get(setting, this.get(setting));\n\t\t\t\t\t\tmarkerRectangle.set(setting, value);\n\t\t\t\t\t\tds.set(setting, value);\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet graphicsArray: Array<Graphics> | undefined = dataItem.get(\"rangeGraphics\");\n\t\t\tif (graphicsArray) {\n\t\t\t\t$array.each(graphicsArray, (graphics) => {\n\t\t\t\t\tgraphics.dispose();\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tgraphicsArray = [];\n\t\t\tdataItem.setRaw(\"rangeGraphics\", graphicsArray);\n\n\t\t\tthis.axisRanges.each((axisRange) => {\n\t\t\t\tconst container = axisRange.container!;\n\t\t\t\tconst rangeGraphics = this._makeGraphics(axisRange.columns, dataItem);\n\t\t\t\tif (graphicsArray) {\n\t\t\t\t\tgraphicsArray.push(rangeGraphics);\n\t\t\t\t}\n\t\t\t\trangeGraphics.setPrivate(\"list\", axisRange.columns);\n\t\t\t\tcontainer.children.push(rangeGraphics);\n\t\t\t})\n\t\t}\n\t}\n\n\tpublic createAxisRange(axisDataItem: DataItem<IAxisDataItem>): this[\"_axisRangeType\"] {\n\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\tconst graphics = dataItem.get(\"graphics\");\n\t\t\tif (graphics) {\n\t\t\t\tgraphics.dispose();\n\t\t\t\tdataItem.set(\"graphics\", undefined);\n\t\t\t}\n\t\t})\n\n\t\treturn super.createAxisRange(axisDataItem);\n\t}\n\n\tprotected _updateGraphics(dataItem: DataItem<this[\"_dataItemSettings\"]>, previousDataItem: DataItem<this[\"_dataItemSettings\"]>, axisCase: 0 | 1 | 2) {\n\t\tlet graphics = dataItem.get(\"graphics\")!;\n\n\t\t//if (!graphics) {\n\t\t//\tthis._createGraphics(dataItem);\n\t\t//\tgraphics = dataItem.get(\"graphics\")!;\n\t\t//}\n\n\t\tconst xField = this._xField;\n\t\tconst yField = this._yField;\n\n\t\tconst valueX = dataItem.get(xField as any);\n\t\tconst valueY = dataItem.get(yField as any);\n\n\t\tconst exactLocationX = this.get(\"exactLocationX\", false);\n\t\t//const exactLocationY = this.get(\"exactLocationY\", false);\t\t\n\n\t\tif (valueX != null && valueY != null) {\n\t\t\tconst xOpenField = this._xOpenField;\n\t\t\tconst yOpenField = this._yOpenField;\n\n\t\t\tconst locationX = this.get(\"locationX\", dataItem.get(\"locationX\", 0.5));\n\t\t\tconst locationY = this.get(\"locationY\", dataItem.get(\"locationY\", 0.5));\n\n\t\t\tconst openLocationX = this.get(\"openLocationX\", dataItem.get(\"openLocationX\", locationX));\n\t\t\tconst openLocationY = this.get(\"openLocationY\", dataItem.get(\"openLocationY\", locationY));\n\n\t\t\tconst width = graphics.get(\"width\");\n\t\t\tconst height = graphics.get(\"height\");\n\n\t\t\tconst stacked = this.get(\"stacked\");\n\n\t\t\tconst xAxis = this.get(\"xAxis\");\n\t\t\tconst yAxis = this.get(\"yAxis\");\n\n\t\t\tconst xStart = xAxis.get(\"start\");\n\t\t\tconst xEnd = xAxis.get(\"end\");\n\n\t\t\tconst yStart = yAxis.get(\"start\");\n\t\t\tconst yEnd = yAxis.get(\"end\");\n\n\t\t\tlet l!: number;\n\t\t\tlet r!: number;\n\t\t\tlet t!: number;\n\t\t\tlet b!: number;\n\n\t\t\tlet vcy = this.get(\"vcy\", 1);\n\t\t\tlet vcx = this.get(\"vcx\", 1);\n\n\t\t\tlet fitW = false;\n\t\t\tlet fitH = false;\n\n\n\t\t\tif (axisCase == 0) {\n\t\t\t\tlet startLocation = this._aLocationX0 + openLocationX - 0.5;\n\t\t\t\tlet endLocation = this._aLocationX1 + locationX - 0.5;\n\n\t\t\t\tif (width instanceof Percent) {\n\t\t\t\t\tlet offset: number = (endLocation - startLocation) * (1 - width.value) / 2;\n\t\t\t\t\tstartLocation += offset;\n\t\t\t\t\tendLocation -= offset;\n\t\t\t\t}\n\n\t\t\t\tl = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx, exactLocationX);\n\t\t\t\tr = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx, exactLocationX);\n\t\t\t\tt = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);\n\n\t\t\t\tif (this._yOpenField !== this._yField) {\n\t\t\t\t\tb = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (stacked) {\n\t\t\t\t\t\tlet stackToItemY = dataItem.get(\"stackToItemY\")!;\n\t\t\t\t\t\tif (stackToItemY) {\n\t\t\t\t\t\t\tb = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, (stackToItemY.component as XYSeries).get(\"vcy\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tb = yAxis.basePosition();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb = yAxis.basePosition();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdataItem.setRaw(\"point\", { x: l + (r - l) / 2, y: t });\n\n\t\t\t\tfitH = true;\n\t\t\t}\n\t\t\telse if (axisCase == 1) {\n\t\t\t\tlet startLocation = this._aLocationY0 + openLocationY - 0.5;\n\t\t\t\tlet endLocation = this._aLocationY1 + locationY - 0.5;\n\n\t\t\t\tif (height instanceof Percent) {\n\t\t\t\t\tlet offset: number = (endLocation - startLocation) * (1 - height.value) / 2;\n\t\t\t\t\tstartLocation += offset;\n\t\t\t\t\tendLocation -= offset;\n\t\t\t\t}\n\n\t\t\t\tt = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);\n\t\t\t\tb = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);\n\t\t\t\tr = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx, exactLocationX);\n\n\t\t\t\tif (this._xOpenField !== this._xField) {\n\t\t\t\t\tl = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx, exactLocationX);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (stacked) {\n\t\t\t\t\t\tlet stackToItemX = dataItem.get(\"stackToItemX\")!;\n\t\t\t\t\t\tif (stackToItemX) {\n\t\t\t\t\t\t\tl = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, (stackToItemX.component as XYSeries).get(\"vcx\"), exactLocationX);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tl = xAxis.basePosition();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl = xAxis.basePosition();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfitW = true;\n\n\t\t\t\tdataItem.setRaw(\"point\", { x: r, y: t + (b - t) / 2 });\n\t\t\t}\n\t\t\telse if (axisCase == 2) {\n\t\t\t\tlet startLocation = this._aLocationX0 + openLocationX - 0.5;\n\t\t\t\tlet endLocation = this._aLocationX1 + locationX - 0.5;\n\n\t\t\t\tif (width instanceof Percent) {\n\t\t\t\t\tlet offset: number = (endLocation - startLocation) * (1 - width.value) / 2;\n\t\t\t\t\tstartLocation += offset;\n\t\t\t\t\tendLocation -= offset;\n\t\t\t\t}\n\n\t\t\t\tl = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);\n\t\t\t\tr = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);\n\n\t\t\t\tstartLocation = this._aLocationY0 + openLocationY - 0.5;\n\t\t\t\tendLocation = this._aLocationY1 + locationY - 0.5;\n\n\t\t\t\tif (height instanceof Percent) {\n\t\t\t\t\tlet offset: number = (endLocation - startLocation) * (1 - height.value) / 2;\n\t\t\t\t\tstartLocation += offset;\n\t\t\t\t\tendLocation -= offset;\n\t\t\t\t}\n\n\t\t\t\tt = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);\n\t\t\t\tb = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);\n\n\t\t\t\tdataItem.setRaw(\"point\", { x: l + (r - l) / 2, y: t + (b - t) / 2 });\n\t\t\t}\n\n\t\t\tthis._applyGraphicsStates(dataItem, previousDataItem);\n\t\t\tthis._updateSeriesGraphics(dataItem, graphics!, l, r, t, b, fitW, fitH);\n\n\t\t\tif ((l < xStart && r < xStart) || (l > xEnd && r > xEnd) || (t < yStart && b <= yStart) || (t >= yEnd && b > yEnd) || $type.isNaN(l) || $type.isNaN(t)) {\n\t\t\t\tthis._toggleColumn(dataItem, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._toggleColumn(dataItem, true);\n\t\t\t}\n\n\t\t\tlet rangeGraphics = dataItem.get(\"rangeGraphics\")!;\n\t\t\tif (rangeGraphics) {\n\t\t\t\t$array.each(rangeGraphics, (graphics) => {\n\t\t\t\t\tthis._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._toggleColumn(dataItem, false);\n\t\t}\n\t}\n\n\tprotected _updateSeriesGraphics(dataItem: DataItem<this[\"_dataItemSettings\"]>, graphics: Graphics, l: number, r: number, t: number, b: number, fitW: boolean, fitH: boolean) {\n\t\tconst width = graphics.get(\"width\");\n\t\tconst height = graphics.get(\"height\");\n\t\tconst maxWidth = graphics.get(\"maxWidth\");\n\t\tconst maxHeight = graphics.get(\"maxHeight\");\n\n\t\tconst ptl = this.getPoint(l, t);\n\t\tconst pbr = this.getPoint(r, b);\n\n\t\tconst tooltipPoint = dataItem.get(\"point\");\n\n\t\tif (tooltipPoint) {\n\t\t\tconst point = this.getPoint(tooltipPoint.x, tooltipPoint.y);\n\t\t\ttooltipPoint.x = point.x + this._x;\n\t\t\ttooltipPoint.y = point.y + this._y;\n\t\t}\n\n\t\tl = ptl.x;\n\t\tr = pbr.x;\n\n\t\tt = ptl.y;\n\t\tb = pbr.y;\n\n\t\tif ($type.isNumber(width)) {\n\t\t\tconst offset: number = ((r - l) - width) / 2;\n\t\t\tl += offset;\n\t\t\tr -= offset;\n\t\t}\n\n\t\tif ($type.isNumber(maxWidth) && maxWidth < Math.abs(r - l)) {\n\t\t\tconst offset: number = ((r - l) - maxWidth) / 2;\n\t\t\tl += offset;\n\t\t\tr -= offset;\n\t\t}\n\n\t\tif ($type.isNumber(height)) {\n\t\t\tconst offset: number = ((b - t) - height) / 2;\n\t\t\tt += offset;\n\t\t\tb -= offset;\n\t\t}\n\n\t\tif ($type.isNumber(maxHeight) && maxHeight < Math.abs(b - t)) {\n\t\t\tconst offset: number = ((b - t) - maxHeight) / 2;\n\t\t\tt += offset;\n\t\t\tb -= offset;\n\t\t}\n\n\t\tif (this.get(\"adjustBulletPosition\")) {\n\t\t\tif (fitW) {\n\t\t\t\tr = Math.min(Math.max(0, r), this._pw);\n\t\t\t\tl = Math.min(Math.max(0, l), this._pw);\n\t\t\t}\n\n\t\t\tif (fitH) {\n\t\t\t\tt = Math.min(Math.max(0, t), this._ph);\n\t\t\t\tb = Math.min(Math.max(0, b), this._ph);\n\t\t\t}\n\t\t}\n\n\t\tdataItem.setRaw(\"left\", l);\n\t\tdataItem.setRaw(\"right\", r);\n\t\tdataItem.setRaw(\"top\", t);\n\t\tdataItem.setRaw(\"bottom\", b);\n\n\t\tgraphics.setPrivate(\"width\", r - l);\n\t\tgraphics.setPrivate(\"height\", b - t);\n\t\tgraphics.set(\"x\", l);\n\t\tgraphics.set(\"y\", b - (b - t));\n\t}\n\n\tprotected _handleDataSetChange() {\n\t\tsuper._handleDataSetChange();\n\t\t$array.each(this._dataItems, (dataItem) => {\n\t\t\tthis._toggleColumn(dataItem, false);\n\t\t})\n\t}\n\n\tpublic _applyGraphicsStates(dataItem: DataItem<this[\"_dataItemSettings\"]>, previousDataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\n\t\tconst graphics = dataItem.get(\"graphics\")!;\n\n\t\tconst dropFromOpen = graphics.states.lookup(\"dropFromOpen\");\n\t\tconst riseFromOpen = graphics.states.lookup(\"riseFromOpen\");\n\n\t\tconst dropFromPrevious = graphics.states.lookup(\"dropFromPrevious\");\n\t\tconst riseFromPrevious = graphics.states.lookup(\"riseFromPrevious\");\n\n\t\tif (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {\n\t\t\tconst xAxis = this.get(\"xAxis\");\n\t\t\tconst yAxis = this.get(\"yAxis\");\n\t\t\tconst baseAxis = this.get(\"baseAxis\");\n\n\t\t\tlet open: number | undefined;\n\t\t\tlet close: number | undefined;\n\t\t\tlet previousClose: number | undefined;\n\n\t\t\tif (baseAxis === xAxis && yAxis.isType<ValueAxis<any>>(\"ValueAxis\")) {\n\t\t\t\topen = dataItem.get(this._yOpenField as any);\n\t\t\t\tclose = dataItem.get(this._yField as any);\n\n\t\t\t\tpreviousClose = previousDataItem.get(this._yField as any);\n\t\t\t}\n\t\t\telse if (baseAxis === yAxis && xAxis.isType<ValueAxis<any>>(\"ValueAxis\")) {\n\t\t\t\topen = dataItem.get(this._xOpenField as any);\n\t\t\t\tclose = dataItem.get(this._xField as any);\n\n\t\t\t\tpreviousClose = previousDataItem.get(this._xField as any);\n\t\t\t}\n\n\t\t\tif ($type.isNumber(open) && $type.isNumber(close)) {\n\t\t\t\tif (close < open) {\n\t\t\t\t\tif (dropFromOpen) {\n\t\t\t\t\t\tdropFromOpen.apply();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (riseFromOpen) {\n\t\t\t\t\t\triseFromOpen.apply();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($type.isNumber(previousClose)) {\n\t\t\t\t\tif (close < previousClose) {\n\t\t\t\t\t\tif (dropFromPrevious) {\n\t\t\t\t\t\t\tdropFromPrevious.apply();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (riseFromPrevious) {\n\t\t\t\t\t\t\triseFromPrevious.apply();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic disposeDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tsuper.disposeDataItem(dataItem);\n\t\tconst graphics = dataItem.get(\"graphics\");\n\t\tif (graphics) {\n\t\t\tthis.columns.removeValue(graphics);\n\t\t\tgraphics.dispose();\n\t\t}\n\n\t\tconst rangeGraphics = dataItem.get(\"rangeGraphics\")!;\n\t\tif (rangeGraphics) {\n\t\t\t$array.each(rangeGraphics, (graphics) => {\n\t\t\t\tconst list = graphics.getPrivate(\"list\");\n\t\t\t\tif (list) {\n\t\t\t\t\tlist.removeValue(graphics);\n\t\t\t\t}\n\t\t\t\tgraphics.dispose();\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Hides series's data item.\n\t * \n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async hideDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.hideDataItem(dataItem, duration)];\n\t\tconst graphics = dataItem.get(\"graphics\");\n\t\tif (graphics) {\n\t\t\tpromises.push(graphics.hide(duration));\n\t\t}\n\n\t\tconst rangeGraphics = dataItem.get(\"rangeGraphics\")!;\n\t\tif (rangeGraphics) {\n\t\t\t$array.each(rangeGraphics, (graphics) => {\n\t\t\t\tpromises.push(graphics.hide(duration));\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\tprotected _toggleColumn(dataItem: DataItem<this[\"_dataItemSettings\"]>, visible: boolean) {\n\t\tconst graphics = dataItem.get(\"graphics\");\n\t\tif (graphics) {\n\t\t\tgraphics.setPrivate(\"visible\", visible);\n\t\t}\n\n\t\tconst rangeGraphics = dataItem.get(\"rangeGraphics\")!;\n\t\tif (rangeGraphics) {\n\t\t\t$array.each(rangeGraphics, (graphics) => {\n\t\t\t\tgraphics.setPrivate(\"visible\", visible);\n\t\t\t})\n\t\t}\n\n\t\tconst bullets = dataItem.bullets;\n\t\tif (bullets) {\n\t\t\t$array.each(bullets, (bullet) => {\n\t\t\t\tbullet.setPrivate(\"hidden\", !visible);\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Shows series's data item.\n\t * \n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async showDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.showDataItem(dataItem, duration)];\n\t\tconst graphics = dataItem.get(\"graphics\");\n\t\tif (graphics) {\n\t\t\tpromises.push(graphics.show(duration));\n\t\t}\n\n\t\tconst rangeGraphics = dataItem.get(\"rangeGraphics\")!;\n\t\tif (rangeGraphics) {\n\t\t\t$array.each(rangeGraphics, (graphics) => {\n\t\t\t\tpromises.push(graphics.show(duration));\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateLegendMarker(dataItem?: DataItem<IBaseColumnSeriesDataItem>) {\n\t\tlet legendDataItem = this.get(\"legendDataItem\");\n\n\t\tif (this.get(\"useLastColorForLegendMarker\")) {\n\t\t\tif (!dataItem) {\n\t\t\t\tconst lastDataItem = this.dataItems[this.endIndex() - 1];\n\t\t\t\tif (lastDataItem) {\n\t\t\t\t\tdataItem = lastDataItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (legendDataItem) {\n\n\t\t\tlet graphics: Template<Graphics> | Graphics = this.columns.template;\n\t\t\tif (dataItem) {\n\t\t\t\tlet column = dataItem.get(\"graphics\");\n\t\t\t\tif (column) {\n\t\t\t\t\tgraphics = column;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst markerRectangle = legendDataItem.get(\"markerRectangle\");\n\n\t\t\tif (markerRectangle) {\n\t\t\t\tif (!legendDataItem.get(\"itemContainer\").get(\"disabled\")) {\n\t\t\t\t\tconst ds = markerRectangle.states.lookup(\"default\")!;\n\t\t\t\t\t$array.each(visualSettings, (setting: any) => {\n\t\t\t\t\t\tconst value = graphics.get(setting, this.get(setting));\n\t\t\t\t\t\tmarkerRectangle.set(setting, value);\n\t\t\t\t\t\tds.set(setting, value);\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _getTooltipTarget(dataItem: DataItem<this[\"_dataItemSettings\"]>): Sprite {\n\t\tif (this.get(\"seriesTooltipTarget\") == \"bullet\") {\n\t\t\treturn super._getTooltipTarget(dataItem);\n\t\t}\n\n\t\tlet column = dataItem.get(\"graphics\");\n\t\tif (column) {\n\t\t\treturn column;\n\t\t}\n\t\treturn this;\n\t}\n}\n","import type { DataItem } from \"../../../core/render/Component\";\r\nimport type { Color } from \"../../../core/util/Color\";\r\n\r\nimport { BaseColumnSeries, IBaseColumnSeriesPrivate, IBaseColumnSeriesSettings, IBaseColumnSeriesDataItem, IBaseColumnSeriesAxisRange } from \"./BaseColumnSeries\";\r\nimport { Template } from \"../../../core/util/Template\";\r\nimport { ListTemplate } from \"../../../core/util/List\";\r\nimport { RoundedRectangle } from \"../../../core/render/RoundedRectangle\";\r\nimport { Graphics } from \"../../../core/render/Graphics\";\r\n\r\nimport * as $utils from \"../../../core/util/Utils\";\r\nimport * as $array from \"../../../core/util/Array\";\r\n\r\nexport interface IColumnSeriesDataItem extends IBaseColumnSeriesDataItem { }\r\n\r\nexport interface IColumnSeriesSettings extends IBaseColumnSeriesSettings {\r\n\r\n\t/**\r\n\t * Enables \"turbo mode\" of rendering.\r\n\t * \r\n\t * If enabled, the columsn will be drawn directly on canvas, rather than\r\n\t * each individually, significantly speeding up the rendering. Especially\r\n\t * on column-heavy charts.\r\n\t *\r\n\t * NOTE: this is an experimental feature and may not work in all setups. Some\r\n\t * features might be disabled, too, e.g. pointer events and rounded corners.\r\n\t *\r\n\t * @since 5.14.0\r\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/column-series/#Turbo_mode} for more info\r\n\t */\r\n\tturboMode?: boolean;\r\n\r\n}\r\n\r\nexport interface IColumnSeriesPrivate extends IBaseColumnSeriesPrivate { }\r\n\r\nexport interface IColumnSeriesAxisRange extends IBaseColumnSeriesAxisRange {\r\n\t/**\r\n\t * A list of actual columns in a range.\r\n\t */\r\n\tcolumns: ListTemplate<RoundedRectangle>\r\n}\r\n\r\nexport class ColumnSeries extends BaseColumnSeries {\r\n\r\n\tdeclare public _settings: IColumnSeriesSettings;\r\n\tdeclare public _privateSettings: IColumnSeriesPrivate;\r\n\tdeclare public _dataItemSettings: IColumnSeriesDataItem;\r\n\tdeclare public _axisRangeType: IColumnSeriesAxisRange;\r\n\r\n\tpublic allColumns: Graphics = this.children.push(Graphics.new(this._root, {}));\r\n\tpublic allColumnsData: Array<{ width: number, height: number, x: number, y: number, lowX0?: number, lowY0?: number, lowX1?: number, lowY1?: number, highX0?: number, highY0?: number, highX1?: number, highY1?: number, stroke?: Color, fill?: Color, strokeWidth: number, strokeOpacity: number, fillOpacity: number }> = [];\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic makeColumn(dataItem: DataItem<this[\"_dataItemSettings\"]>, listTemplate: ListTemplate<RoundedRectangle>): RoundedRectangle {\r\n\t\tconst column = listTemplate.make();\r\n\t\tif (!this.get(\"turboMode\")) {\r\n\t\t\tthis.mainContainer.children.push(column);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcolumn.virtualParent = this.chart;\r\n\t\t}\r\n\r\n\t\tcolumn._setDataItem(dataItem);\r\n\t\tlistTemplate.push(column);\r\n\t\treturn column;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[TemplateList]] of all columns in series.\r\n\t *\r\n\t * `columns.template` can be used to set default settings for all columns,\r\n\t * or to change on existing ones.\r\n\t */\r\n\tpublic readonly columns: ListTemplate<RoundedRectangle> = this.addDisposer(new ListTemplate(\r\n\t\tTemplate.new({}),\r\n\t\t() => RoundedRectangle._new(this._root, {\r\n\t\t\tposition: \"absolute\",\r\n\t\t\tthemeTags: $utils.mergeTags(this.columns.template.get(\"themeTags\", []), [\"series\", \"column\"])\r\n\t\t}, [this.columns.template])\r\n\t));\r\n\r\n\tpublic static className: string = \"ColumnSeries\";\r\n\tpublic static classNames: Array<string> = BaseColumnSeries.classNames.concat([ColumnSeries.className]);\r\n\r\n\r\n\tprotected _processAxisRange(axisRange: this[\"_axisRangeType\"]) {\r\n\t\tsuper._processAxisRange(axisRange);\r\n\t\taxisRange.columns = new ListTemplate(\r\n\t\t\tTemplate.new({}),\r\n\t\t\t() => RoundedRectangle._new(this._root, {\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\tthemeTags: $utils.mergeTags(axisRange.columns.template.get(\"themeTags\", []), [\"series\", \"column\"]),\r\n\t\t\t}, [this.columns.template, axisRange.columns.template])\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _beforeColumnsDraw() {\r\n\t\tthis.allColumnsData = [];\r\n\t}\r\n\r\n\tprotected _afterColumnsDraw() {\r\n\t\tif (this.get(\"turboMode\")) {\r\n\r\n\t\t\tthis.allColumns.set(\"draw\", (display) => {\r\n\t\t\t\tdisplay.clear();\r\n\r\n\t\t\t\t$array.each(this.allColumnsData, (column) => {\r\n\t\t\t\t\tconst w = column.width;\r\n\t\t\t\t\tconst h = column.height;\r\n\t\t\t\t\tconst x = column.x;\r\n\t\t\t\t\tconst y = column.y;\r\n\t\t\t\t\tconst stroke = column.stroke;\r\n\t\t\t\t\tconst fill = column.fill;\r\n\t\t\t\t\tconst strokeWidth = column.strokeWidth;\r\n\t\t\t\t\tconst strokeOpacity = column.strokeOpacity;\r\n\t\t\t\t\tconst fillOpacity = column.fillOpacity;\r\n\r\n\t\t\t\t\tdisplay.beginFill(fill, fillOpacity);\r\n\t\t\t\t\tdisplay.beginPath();\r\n\t\t\t\t\tdisplay.lineStyle(strokeWidth, stroke, strokeOpacity);\r\n\t\t\t\t\tdisplay.drawRect(x, y, w, h);\r\n\t\t\t\t\tdisplay.endStroke();\r\n\t\t\t\t\tdisplay.endFill();\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected _updateSeriesGraphics(dataItem: DataItem<this[\"_dataItemSettings\"]>, graphics: Graphics, l: number, r: number, t: number, b: number, fitW: boolean, fitH: boolean) {\r\n\t\tif (this.get(\"turboMode\")) {\r\n\t\t\tconst stroke = graphics.get(\"stroke\");\r\n\t\t\tconst fillOpacity = graphics.get(\"fillOpacity\", 1);\r\n\t\t\tconst strokeOpacity = graphics.get(\"strokeOpacity\", 1);\r\n\t\t\tconst strokWidth = graphics.get(\"strokeWidth\", 1);\r\n\t\t\tconst fill = graphics.get(\"fill\");\r\n\r\n\t\t\tconst ptl = this.getPoint(l, t);\r\n\t\t\tconst pbr = this.getPoint(r, b);\r\n\r\n\t\t\tconst tooltipPoint = dataItem.get(\"point\");\r\n\r\n\t\t\tif (tooltipPoint) {\r\n\t\t\t\tconst point = this.getPoint(tooltipPoint.x, tooltipPoint.y);\r\n\t\t\t\ttooltipPoint.x = point.x + this._x;\r\n\t\t\t\ttooltipPoint.y = point.y + this._y;\r\n\t\t\t}\r\n\r\n\t\t\tl = ptl.x;\r\n\t\t\tr = pbr.x;\r\n\r\n\t\t\tt = ptl.y;\r\n\t\t\tb = pbr.y;\r\n\r\n\t\t\tdataItem.setRaw(\"left\", l);\r\n\t\t\tdataItem.setRaw(\"right\", r);\r\n\t\t\tdataItem.setRaw(\"top\", t);\r\n\t\t\tdataItem.setRaw(\"bottom\", b);\r\n\r\n\t\t\tthis.allColumnsData.push({ width: r - l, height: b - t, x: l, y: t, stroke: stroke, fill: fill, strokeWidth: strokWidth, strokeOpacity: strokeOpacity, fillOpacity: fillOpacity });\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsuper._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);\r\n\t\t}\r\n\t}\r\n}\r\n"],"names":["CategoryAxis","Axis","constructor","Object","defineProperty","_afterNew","this","_settings","themeTags","$utils","fields","push","setPrivateRaw","addTag","super","_afterDataChange","len","dataItems","length","Math","min","getPrivate","_prepareChildren","i","_valuesDirty","_itemMap","$array","dataItem","setRaw","get","start","end","indices","_getIndices","startIndex","endIndex","_sizeDirty","isDirty","isPrivateDirty","_handleRangeChange","_prepareAxisItems","_updateAxisRanges","adjustZoom","maxZoomCount","minZoomCount","count","sAnimation","_sAnimation","eAnimation","_eAnimation","getIndices","stopped","Number","to","c","zoomToIndexes","series","startCategory","endCategory","baseAxis","xAxis","yAxis","_markDirtyAxes","key","openKey","otherAxis","ValueAxis","startDataItem","endDataItem","findDataItem","categoryAxis","category","direction","idx","categoryToIndex","searchCategory","item","indexOf","setPrivate","hasValue","__valueXShowFields","__valueYShowFields","renderer","minorLabelsEnabled","minorGridEnabled","maxCount","axisLength","max","frequency","ceil","floor","_frequency","j","_toggleDataItem","f","_createAssets","_prepareDataItem","_a","_updateGhost","fillIndex","categoryLocation","endCategoryLocation","index","$type","position","indexToPosition","fillEndIndex","fillEndPosition","endPosition","updateLabel","updateGrid","updateTick","updateFill","_processBullet","updateBullet","fillRule","baseValue","basePosition","getX","value","axisDataItem","positionToCoordinate","NaN","getY","getDataItemPositionX","field","cellLocation","_axisLocation","getDataItemCoordinateX","getDataItemPositionY","getDataItemCoordinateY","location","final","startLocation","endLocation","name","modCount","acc","categoryToPosition","dataItemToPosition","roundAxisPosition","axisPositionToIndex","modifiedLen","cellSizes","cellSize","rel","$math","getTooltipText","_adjustPosition","label","populateString","_updateTooltipText","tooltip","_setDataItem","text","markDirtyText","getSeriesItem","fieldName","seriesDataItem","round","duration","zoom","zoomToCategories","getCellWidthPosition","nextPosition","toGlobalPosition","classNames","concat","className","BaseColumnSeries","XYSeries","_makeGraphics","listTemplate","makeColumn","_makeFieldNames","valueAxis","isType","_xOpenField","_xField","_yOpenField","_yField","inited","_createGraphics","_updateChildren","chart","_ph","plotContainer","height","_pw","width","columnsTemplate","columns","template","set","clusterCount","stacked","xRenderer","yRenderer","cellStartLocation","cellEndLocation","cellLocationX0","cellLocationX1","cellLocationY0","cellLocationY1","_aLocationX0","_aLocationX1","_aLocationY0","_aLocationY1","_axesDirty","_stackDirty","_toggleColumn","previous","_beforeColumnsDraw","axisCase","_updateGraphics","_afterColumnsDraw","_columnsUpdated","_skipped","updateLegendMarker","_afterChanged","graphics","legendDataItem","markerRectangle","ds","states","lookup","visualSettings","setting","graphicsArray","dispose","axisRanges","each","axisRange","container","rangeGraphics","children","createAxisRange","undefined","previousDataItem","xField","yField","valueX","valueY","exactLocationX","xOpenField","yOpenField","locationX","locationY","openLocationX","openLocationY","xStart","xEnd","yStart","yEnd","l","r","t","b","vcy","vcx","fitW","fitH","Percent","offset","stackToItemY","component","x","y","stackToItemX","_applyGraphicsStates","_updateSeriesGraphics","maxWidth","maxHeight","ptl","getPoint","pbr","tooltipPoint","point","_x","_y","abs","_handleDataSetChange","_dataItems","dropFromOpen","riseFromOpen","dropFromPrevious","riseFromPrevious","open","close","previousClose","apply","disposeDataItem","removeValue","list","hideDataItem","promises","_super","call","hide","Promise","all","visible","bullets","bullet","showDataItem","show","lastDataItem","column","_getTooltipTarget","ColumnSeries","Graphics","new","_root","addDisposer","ListTemplate","Template","RoundedRectangle","_new","make","virtualParent","mainContainer","_processAxisRange","allColumnsData","allColumns","display","clear","w","h","stroke","fill","strokeWidth","strokeOpacity","fillOpacity","beginFill","beginPath","lineStyle","drawRect","endStroke","endFill","strokWidth"],"sourceRoot":""}